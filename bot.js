// Generated by LiveScript 1.5.0
(function(){
  var games, util, choose, command, controller, execute, using, safely, txt, out$ = typeof exports != 'undefined' && exports || this;
  games = require('./games');
  util = require('./util');
  choose = util.fromRandom;
  command = /\s*(\S+)\s*(.+)?/;
  function ask(question){
    if (question) {
      if (games.questions.hasOwnProperty(question)) {
        return util.fromRandom(games.questions[question]);
      } else {
        return 'Your options are ' + Object.keys(games.questions).join(', ');
      }
    } else {
      return util.fromRandom(games.questions);
    }
  }
  function vote(command){
    var lower;
    if (!deepEq$(command.indexOf('on'), -1, '===')) {
      global.voteTally = {
        yes: 0,
        no: 0
      };
      return 'starting a vote';
    } else if (!deepEq$(command.indexOf('off'), -1, '===') && global.voteTally != null) {
      return [(function(){
        var i$, ref$, own$ = {}.hasOwnProperty, results$ = [];
        for (i$ in ref$ = global.voteTally) if (own$.call(ref$, i$)) {
          if (ref$[i$] > 0) {
            results$.push((fn$.call(this, i$, ref$[i$])));
          }
        }
        return results$;
        function fn$(key, value){
          return key + ' = ' + value;
        }
      }.call(this))].join('\n');
    } else if (global.voteTally != null && command != null) {
      lower = command.toLowerCase();
      global.voteTally[lower] = global.voteTally[lower] || 1;
      return lower + " now has " + global.voteTally[lower] + " votes";
    } else {
      return 'say "vote on" to start a vote, "vote off" to tally up a vote and "vote yes" or "vote no" to cast your ballot.';
    }
  }
  controller = {
    say: function(it){
      return it + "";
    },
    flip: function(){
      return choose(['heads', 'tails']);
    },
    roll: function(it){
      return '' + (it
        ? util.upTo(parseInt(it))
        : util.upTo());
    },
    ask: ask,
    tell: function(){
      return util.fromRandom(games.answers);
    },
    vote: vote
  };
  execute = function(command, content){
    if (controller.hasOwnProperty(command)) {
      return controller[command](content);
    }
  };
  using = function(message){
    var that;
    if (that = message.match(command)) {
      return execute(that[1].toLowerCase(), that[2]);
    }
  };
  safely = function(content){
    return content || 'I have nothing to say.';
  };
  txt = function(it){
    return it.reply(safely(using(it.body)));
  };
  out$.txt = txt;
  out$.safely = safely;
  out$.using = using;
  out$.execute = execute;
  out$.controller = controller;
  out$.command = command;
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) {
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
